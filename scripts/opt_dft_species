#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""test script to optimize all systems in the DB

all systems with zero energy and not TS are picked and optimized
"""

import pylmps
import molsys
import sys
import os
import time
import numpy as np
import ast
from molsys.util import RDB
from molsys.util import turbomole

#
# class defintions 
#
class turbomole_calculator:

    def __init__(self, params : dict):
       # sanity checks
       assert "submit" in params, "To submit or not to submit? That is the queuing question."
       assert "species" in params, "The type of species is specified"

       # lot should be set as specified in the Tmole manual
       # R. Ahlrichs et al., “Chapter 3.3 Running Turbomole using the script TMOLE,” in
       # Turbomole User’s Manual Version 6.0, 2009, pp. 38–44
       # https://www.cms.hu-berlin.de/de/dl/systemservice/computeservice/docs/turbo58_html
       # 
       # TODO the turbomole module needs generalization...
       lot_DFT = params["lot"]

       # get the current working directory
       self.main_dir = os.getcwd()

       # if a path for the data is not assigned, set the current working directory for that
       if "data_storage_path" in params:
           self.data_dir = params["data_storage_path"]
       else:
           self.data_dir = self.main_dir

       # create a DFT folder with the name of the method
       dft_functional = lot_DFT.split("/")[0]
       basis_set = lot_DFT.split("/")[1]
       dft_dir_name = "-".join([dft_functional,basis_set])
       self.dft_path = os.path.join(self.data_dir, dft_dir_name)
       if not os.path.isdir(self.dft_path):
           os.mkdir(self.dft_path)

       # default parameters
       if "turbodir" not in params:
           params["turbodir"] = os.popen("echo $TURBODIR").read() 
       elif "maxmem" not in params:
           params["maxmem"] = 3000

       # default parameters for job submission and set the other variables
       if params["submit"]:
           if "ntasks" not in params:
               params["ntasks"] = 8
           elif "partition" not in params:
               params["partition"] = "normal" 
           elif "maxnodes" not in params:
               params["maxnodes"] = 4
           # write the SLURM job submission script 'submit.sh' to the QM calculation home directory 
           turbomole.Slurm.write_submission_script(self.dft_path, params["turbodir"], params["ntasks"], params["partition"])
           CPUS, MEM = turbomole.Slurm.get_partition_info(params["partition"])
           MEM_per_CPU = MEM/CPUS
           params["maxmem"] = 0.8*MEM_per_CPU
           njobs_per_node = CPUS/params["ntasks"]
           self.max_njobs = params["maxnodes"]*njobs_per_node
       self.params = params
       return

    def make_dft_subdir(self, specID, db_path):
       # Create the subdirectory for the DFT calculation
       subdir_name = '%05d' % specID
       dft_subdir_path = os.path.abspath(os.path.join(self.dft_path, subdir_name))
       exists = os.path.isdir(dft_subdir_path)
       inDB = False
       if exists:
           rdb = RDB.RDB(db_path)
           db = rdb.db
           dft_spec = db(db.opt_species.path == dft_subdir_path).select().first()
           if dft_spec != None: inDB = True
       else:
           os.mkdir(dft_subdir_path)
          
       return dft_subdir_path, exists, inDB


    def optimize(self, specID, ref_struc_path, TS = False, M = None, rbonds = [], path_ref_educts = [], path_ref_products = []):

       # initialize the OptimizationTools class from the turbomole module under molsys/util/turbomole.py
       ST = turbomole.OptimizationTools(dft_subdir_path)

       # we only fix the internal coordinates between the atoms involved in bond-order change. So convert the bonds into atoms list.
       active_atoms = list(set(rbonds))

       ###############################   to optimize each species in series     ###########################################
       if not self.params["submit"]:
          os.chdir(dft_subdir_path)

          if TS:
              # Do not perform Fermi smearing. The multiplicity is determined by the educts and products.
              print("TS workflow is not implemented yet.")
              sys.exit(1)
              fermi = False
              #atom, converged, init_energy = ST.common_workflow(fermi, M, active_atoms, self.params["maxmem"], ref_struc_path, self.params["lot"])
              #found, reason = ST.transition_state_workflow(active_atoms, path_ref_educts, path_ref_products)
              #final_energy, zpe = turbomole.Harvest().get_energy()
 
          else:
              # Perform Fermi smearing to find the multiplicity of the equilibrium structures
              fermi = True
              atom, converged, init_energy = ST.common_workflow(fermi, M, active_atoms, self.params["maxmem"], ref_struc_path, self.params["lot"])
              if atom:
                  found = converged
                  final_energy = init_energy
                  zpe = 0
              else:
                  found, reason = ST.minima_workflow()
                  final_energy, zpe = turbomole.Harvest().get_energy()

          os.chdir(self.data_dir)
          return found, reason, init_energy, final_energy, zpe

       ################################  to submit to the queue for each species ######################################
       else:
          os.chdir(dft_subdir_path)

          # write the submit.py script which does basically the same thing as the routine written above
          ST.write_submit_py(TS, M, active_atoms, self.params["maxmem"], ref_struc_path, self.params["lot"], path_ref_educts, path_ref_products)
          # submit the job to the SLURM queuing system and get the assigned job id
          sbatchout = os.popen("sbatch -J spec%d %s" %(specID, os.path.join(self.dft_path,"submit.sh"))).read()
          jobid = sbatchout.split()[3]

          os.chdir(self.data_dir)
          return jobid

    def get_multiplicity(dft_subdir_path):
       GT = turbomole.GeneralTools(dft_subdir_path)
       nalpha, nbeta = GT.get_nalpha_and_nbeta_from_ridft_output()
       M = GT.calculate_spin_multiplicity_from(nalpha, nbeta) 
       return M

    def get_energy(dft_subdir_path, atom):       
       """ Read the energy from the aoforce output or from the ridft output.
       SPE: Single point energy
       ZPE: Zero point vibrational energy
       """
       GT = turbomole.GeneralTools(dft_subdir_path)
       if atom:
           SPE = GT.get_energy_from_ridft_out()
           ZPE = 0.0
       else:
           SPE, ZPE = GT.get_energy_from_aoforce_out() 
       return  SPE, ZPE

    def get_mol(dft_subdir_path):
       os.system("t2x %s/coord > %s/coord.xyz" %(dft_subdir_path, dft_subdir_path))
       mol = molsys.mol.from_file(os.path.join(dft_subdir_path,"coord.xyz"))
       return mol




#
# Helper functions
#
def get_mol_from_opt_spec(ospec):
    # get mol object from DB
    fname, mfpxf = db.opt_species.mfpx.retrieve(ospec.mfpx)
    mfpxs = mfpxf.read().decode('utf-8')
    mfpxf.close()
    mol = molsys.mol.from_string(mfpxs)
    mol.addon("graph")
    mol.graph.make_comp_graph()
    return mol

def get_opt_spec_path(ospec):
    fname, mfpxf = db.opt_species.mfpx.retrieve(ospec.mfpx)
    ospec_mfpxf_path = mfpxf.name
    mfpxf.close()
    return ospec_mfpxf_path

def get_ncurjobs(jobids):
    squeueout = os.popen('squeue --format="%A"').read()
    squeuelist=squeueout.split()
    curjobids=set(jobids).intersection(squeuelist)
    ncurjobs = len(curjobids)
    return ncurjobs, curjobids



######################################################################################################################
######################################################################################################################
#
# Start of main program 
#
if len(sys.argv) < 2:
    print ("usage:  opt_md_species <db_path> <pdlp_file> <stage>")
    exit()
    

db_path   = sys.argv[1]
pdlp_path = sys.argv[2]
pdlp_path = os.path.abspath(pdlp_path)
stage     = sys.argv[3]
start_lot = sys.argv[4]
cmd_file  = sys.argv[5]

assert os.path.isfile(cmd_file), "command file exists!"

print ("open database %s" % db_path)
rdb = RDB.RDB(db_path)
print ("dealing with MD from file %s and stage %s"  % (pdlp_path, stage))

# get all entries in md_species not TS (access pydal  directly TBI: some clever routines in rdb to handle this)
db = rdb.db
md = db((db.md.path == pdlp_path) & (db.md.stage == stage)).select().first()

reactions = db(db.reactions).select() 

start_lotID = rdb.get_lot(start_lot)

# read param set. Examples are:
# ------------------------------
# DFT could look like
#params = { "calculator"        : "turbomole" 
#         , "species"           : "eq" or "ts"
#         , "data_storage_path' : '/home/oyoender/DATA/'
#         , "lot"               : "tpssh/TZVP"
#         , "maxmem"            : 3000
#         , "submit"            : True
#         , "turbodir"          : /opt/software/user-soft/turbomole/release
#         , "ntasks"            : 8
#         , "maxnodes"          : 4
#         , "partition"         : "normal"
#         }

file = open(cmd_file, "r")
content = file.read()
params = ast.literal_eval(content)

# sanity check(s)
assert "calculator" in params, "Calculator defined"
assert "lot" in params, "Level of Theory given for calculator"

if params["calculator"] == "turbomole":
    calculator = turbomole_calculator(params)

lotID = rdb.get_lot(params["lot"])

path = ""
dft_subdir_paths = {}
specIDs = {}
rbonds = []
curjobids = []
ncurjobs = 0
jobids = []
counter = 0

if params["submit"]:
     n_eq = 0
     n_ts = -1
     for r in reactions:
         reac2eq_spec  = db((db.reac2spec.reactionsID == r) & (db.reac2spec.label != 0)).select()
         for eq_spec in reac2eq_spec:
             n_eq += 1
         n_ts += 1

     print(n_eq, n_ts)


# Loop over the reactions
for r in reactions:
    # get all species for this reaction
    reac2spec   = db((db.reac2spec.reactionsID == r)).select()
    reac2eq_spec  = db((db.reac2spec.reactionsID == r) & (db.reac2spec.label != 0)).select()
    ts_spec = db((db.reac2spec.reactionsID == r) & (db.reac2spec.label ==  0)).select().first()

    #################################### for the TS ######################################
    if params["species"] == "ts":
        if r.id != 1:
            # We need the QM optimized educt and product species 
            # 1) to determine the spin multiplicity of the TS and 
            # 2) to compare the end points of intrinsic reaction coordinate.
            # Therefore, select the optimized educts and products at the specified QM lot.
            reac2educt_spec = db((db.reac2spec.reactionsID == r) & (db.reac2spec.label == -1)).select()
            oeds = []
            for ed in reac2educt_spec:
                oed = db((db.opt_species.speciesID == ed.speciesID) & (db.opt_species.lotID == lotID)).select().first()
                oeds.append(oed)

            reac2proc_spec  = db((db.reac2spec.reactionsID == r) & (db.reac2spec.label ==  1)).select()
            oprods = []
            for prod in reac2proc_spec:
                oprod = db((db.opt_species.speciesID == prod.speciesID) & (db.opt_species.lotID == lotID)).select().first()
                oprods.append(oprod)

            # Now select the start_lot (e.g. ReaxFF) pre-optimized TS species.
            print(ts_spec)
            ots =  db((db.opt_species.speciesID == ts_spec.speciesID) & (db.opt_species.lotID == start_lotID)).select().first()
            ots_mfpx_path = get_opt_spec_path(ots)
            rbonds = ots["rbonds"]

    ############################## for the equilibrium structures ########################
    else:
        for spec in reac2eq_spec:
            counter += 1
            if counter < n_eq:
                specID = spec["speciesID"]
                # Select the start_lot (e.g. ReaxFF) optimized equilibrium species.
                ospec = db((db.opt_species.speciesID == specID) & (db.opt_species.lotID == start_lotID)).select().first()
                ospec_mfpx_path = get_opt_spec_path(ospec)
                if params["calculator"] == "turbomole":

                    ################################# submission to the queuing system ##################################
                    if params["submit"]:
                        # submit the jobs to the specifies number of total cores.
                        while ncurjobs == calculator.max_njobs:
                            print("Maximum number of jobs running at the same time is reached. Waiting for the jobs %s to finish." %str(list(curjobids)))              
                            time.sleep(30)
                            ncurjobs, curjobids = get_ncurjobs(jobids)
                        # submit the job to the queue and get the job id from the queing system
                        dft_subdir_path, exists, inDB = calculator.make_dft_subdir(specID, db_path)
                        if not exists and not inDB:
                            jobid = calculator.optimize(specID, ospec_mfpx_path)
                            # update the variables
                            jobids.append(jobid)
                            dft_subdir_paths[ospec] = dft_subdir_path
                        elif exists and not inDB:
                            print('The directory %s already exists. However, there is no entry in the DB.' %dft_subdir_path)
                        else:
                            print('The directory %s already exists and is in the DB.' %dft_subdir_path)
                        ncurjobs, curjobids = get_ncurjobs(jobids)
                        # if all of the jobs are submitted, wait until all of them are finished
                        if len(jobids) == n_eq:
                            while not ncurjobs == 0:
                                print("Waiting for the final jobs %s to finish..." %str(list(curjobids)))
                                time.sleep(30)
                                ncurjobs, curjobids = get_ncurjobs(jobids)
                            print("All of the jobs are finished.")


                    ##################################### optimize in series  ###########################################
                    else:
                        dft_subdir_path, exists, inDB = calculator.make_dft_subdir(specID, db_path)
                        if not exists and not inDB:
                            found, reason, init_energy, final_energy, zpe = calculator.optimize(specID, ospec_mfpx_path)
                            dft_subdir_paths[ospec] = dft_subdir_path
                        elif exists and not inDB:
                            print('The directory %s already exists. However, there is no entry in the DB.' %dft_subdir_path)
                        else:
                            print('The directory %s already exists and is in the DB.' %dft_subdir_path)

                else:
                   print("Unknown calculator!")
                   sys.exit(1)


#if params["submit"]:
#    if params["species"] == "ts":
#        print("Not implemented yet.")
#        sys.exit(1)
#    else:
#        for ospec in dft_subdir_paths:
#            ospec_mfpx_path = get_opt_spec_path(ospec)
#            dft_subdir_path = dft_subdir_paths[ospec_mfpx_path]
#
#            mol_ini = molsys.mol.from_file(ospec_mfpx_path)
#
#            specID = ospec["speciesID"]
#
#            found = os.path.isfile(os.path.join(dft_subdir_path,'FOUND'))
#
#            if found:
#                # is it an atom or not? get the final energy accordingly...
#                natoms = mol_ini.get_natoms()
#                if natoms == 1: 
#                    atom = True
#                else:
#                    atom = False 
#                final_energy, zpe = calculator.get_energy(dft_subdir_path, atom)
#
#                # rbonds
#                rbonds = ospec["rbonds"]
#
#                # compare the graph of the reference structure and the optimized structure
#                mol_ini.detect_conn(thresh = 0.2)
#                mol_ini.addon("graph")
#                mol_ini.graph.make_comp_graph()
#                molg_init = mol_ini.graph.molg
#                opt_mol = calculator.get_mol(dft_subdir_path)
#                opt_mol.detect_conn(thresh = 0.2)
#                opt_mol.addon("graph")
#                opt_mol.graph.make_comp_graph()
#                molg_opt = opt_mol.graph.molg
#                is_equal, error_code = molsys.addon.graph.is_equal(molg_init, molg_opt)
#                changed = not is_equal
#
#                print(found, opt_mol, param["lot"], final_energy, specID, dft_subdir_path, zpe, changed, rbonds)
#                # add to the database
#                rdb.add_opt_species(opt_mol, params["lot"], final_energy, specID, dft_subdir_path, zpe, changed, rbonds)
#
#            else:
#                reason = open(os.path.join(dft_subdir_path,'NOTFOUND'),'r').read()
#                print('Species %s with lot=%s is not added to the database, due to the reason: %s' %(params["lot"], specID, reason))
#
#
##print ("\n\n############################################")
##print ("initial %12.6f  final %12.6f  zpe %12.6f " % (init_energy, final_energy, zpe))
##print ("############################################\n\n")
### store these results to the DB
### first update coords and get mol object back from lammps
##opt_mol = calculator.get_mol(dft_subdir_path)
##opt_mol.addon("graph")
##opt_mol.graph.make_comp_graph()
##molg_opt = opt_mol.graph.molg
##is_equal, error_code = molsys.addon.graph.is_equal(molg_init, molg_opt)
##if error_code != 0:
##   print("Error during molgraph comparison!")
##   sys.exit(1)
### add to db newly optimized structure
##changed = not is_equal
##rbonds = ospec["rbonds"] # restore the old rbonds add_opt_species does not link numpy arrays :-(
##print(opt_mol, params["lot"], final_energy, specID, path, zpe, changed, rbonds)
## rdb.add_opt_species(opt_mol, params["lot"], final_energy, specID, path=path, zpe, change_molg=changed, rbonds=rbonds)
##calculator.end()
##
##
