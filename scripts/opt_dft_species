#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""test script to optimize all systems in the DB

all systems with zero energy and not TS are picked and optimized
"""

import pylmps
import molsys
import sys
import os
from molsys.util import RDB
from molsys.util import turbomole


from   molsys.util.units import angstrom


if len(sys.argv) < 3:
    print ("usage:  opt_md_species <db_path> <dft_method>")
    exit

# Get the system arguments
db_path = sys.argv[1]
lot_DFT = sys.argv[2]

# Create a DFT folder with the name of the method
dft_functional = lot_DFT.split("/")[0]
basis_set = lot_DFT.split("/")[1]
dft_dir_name = "-".join([dft_functional,basis_set])
maindir = os.getcwd()
dft_path = os.path.join(maindir,dft_dir_name)
if not os.path.isdir(dft_path):
    os.mkdir(dft_path)

# Maximum memory in MB/core
MAXMEM = 500

# The ZPE correction factor dictionary
f_ZPE_dict = {'tpss/SVP':1.0019,'b3-lyp/SVP':0.9912, 'pbe0/SVP':0.9817, 'pbe/SVP':1.0179, 
                                'b3-lyp/TZVP':0.9896,'pbe0/TZVP':0.9830,
              # Reference: https://dx.doi.org/10.1021/jp508422u 
              'tpssh/TZVP':0.9874}
              # Reference:  https://dx.doi.org/10.1021/jp0519464

# Open the database
print ("open database %s" % db_path)
rdb = RDB.RDB(db_path)

# Get all entries in md_species not TS (access pydal  directly TBI: some clever routines in rdb to handle this)
db = rdb.db

lot_FF = rdb.get_lot("ReaxFF")
rows = db(db.opt_species.lotID == lot_FF).select()

# Get the opt_species.id of the similar structures
similar_rows = db(db.opt_species.id == db.similar.opt_speciesID).select()

# Get a dictionary of similar structures
similar_dict = {}
for s in similar_rows:
    similar_dict[s.opt_species.id] = s.similar.similar_opt_speciesID

# Perform the QM calculation only on the species which are unique.
for r in rows:
    if r.id not in similar_dict:
        md_spec = db(db.md_species.id == r.md_speciesID).select().first()
        foffset = md_spec.foffset
        revent = db(db.revent.id == md_spec.reventID).select().first()
        if md_spec.foffset != 0:
            active_atoms = []
        else:
            active_atoms = revent.rbonds
        print(active_atoms)
        fname = "%s/storage/xyz/%s" %(db_path,r.xyz)
        mol = molsys.mol.from_file(fname, "xyz")
        subdir_name = '%05d' % r.id
        dft_subdir_path = os.path.join(dft_path, subdir_name)
        if not os.path.isdir(dft_subdir_path):
            os.mkdir(dft_subdir_path)
        else:
            sys.exit('The directory %s already exists' % dft_subdir_path)

        #--------.----- The determination of orbital occupations -------------#
        # Get a start multiplicitiy for your system before Fermi smearing
        nel = turbomole.Mol(mol).count_number_of_electrons()
        if (nel % 2) == 0:
            M_start = 3
        else:
            M_start = 2

        new_xyz = turbomole.GeometryTools.add_noise(mol = mol, active_atoms = active_atoms)

        # General Tools
        GT = turbomole.GeneralTools(dft_subdir_path)

        # Perform a single point calculation using Fermi smearing
        GT.make_tmole_dft_input_for_fermi_smearing(
                elems=mol.elems, 
                xyz=new_xyz, 
                M_start=M_start, 
                max_mem=MAXMEM, 
                title= r.xyz, 
                lot_DFT=lot_DFT)
        converged = GT.run_tmole()

        # Remove the data group $fermi from the control file
        GT.kdg("fermi")

        # If there are partial occupations round them to integers
        GT.round_fractional_occupation()

        #--------------- The optimization of the structures ------------------#
        if mol.natoms == 1:
            GT.ridft()
            GT.check_dscf_converged()
        else:
            if foffset == 0:
                print("This is a TS.")
            else:
                print("This is either reactant or product.")
                found = turbomole.Submit(dft_subdir_path).minima_workflow()
                if found:
                    final_energy = turbomole.Harvest(dft_subdir_path).get_energy(f_ZPE_dict[lot_DFT])
                    opt_mol = GT.coord_to_mol()
                    rdb.add_opt_species(opt_mol, lot_DFT, final_energy, md_spec.id)


#rows = db((db.md_species.energy == 0.0) & (db.md_species.foffset != 0)).select()
#
#lot = rdb.get_lot("ReaxFF")
#
#for r in rows:
#    print ("retreive species %d (type %d) from reaction event %d" % (r.spec, r.foffset, r.reventID))
#    print (r.smiles)
#    # get mol object from DB
#    fname, mfpxf = db.md_species.mfpx.retrieve(r.mfpx)
#    mfpxs = mfpxf.read().decode('utf-8')
#    mfpxf.close()
#    mol = molsys.mol.from_string(mfpxs)
#    # setup lammps and minimize with reax
#    pl = pylmps.pylmps("reax")
#    pl.setup(mol = mol, local=True, ff="ReaxFF")
#    init_energy = pl.calc_energy()
#    final_energy = pl.MIN(0.01)
#    print ("\n\n#####################################")
#    print ("initial %12.6f  final %12.6f " % (init_energy, final_energy))
#    print ("########################################\n\n")
#    # store these results to the DB
#    # first update coords and get mol object back from lammps
#    pl.update_mol()
#    opt_mol = pl.mol
#    # update the energy value
#    r.update_record(energy=init_energy)
#    rdb.add_opt_species(opt_mol, lot, final_energy, r.id)
#    pl.end()
#
#
#
#
#
#
