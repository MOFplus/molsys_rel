#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""test script to optimize all systems in the DB

all systems with zero energy and not TS are picked and optimized
"""

import pylmps
import molsys
import sys
import os
import time
import numpy as np
import ast
from molsys.util import RDB
from molsys.util import turbomole

#
# class defintions 
#
class turbomole_calculator:

    def __init__(self, params : dict):
       # sanity checks
       assert "submit" in params, "To submit or not to submit? That is the queuing question."
       assert "species" in params, "The type of species is specified"

       # lot should be set as specified in the Tmole manual
       # R. Ahlrichs et al., “Chapter 3.3 Running Turbomole using the script TMOLE,” in
       # Turbomole User’s Manual Version 6.0, 2009, pp. 38–44
       # https://www.cms.hu-berlin.de/de/dl/systemservice/computeservice/docs/turbo58_html
       # 
       # TODO the turbomole module needs generalization...
       lot_DFT = params["lot"]

       # get the current working directory
       self.main_dir = os.getcwd()

       # if a path for the data is not assigned, set the current working directory for that
       if "data_storage_path" in params:
           self.data_dir = params["data_storage_path"]
       else:
           self.data_dir = self.main_dir

       # create a DFT folder with the name of the method
       dft_functional = lot_DFT.split("/")[0]
       basis_set = lot_DFT.split("/")[1]
       dft_dir_name = "-".join([dft_functional,basis_set])
       self.dft_path = os.path.join(self.data_dir, dft_dir_name)
       if not os.path.isdir(self.dft_path):
           os.mkdir(self.dft_path)

       # default parameters
       if "turbodir" not in params:
           params["turbodir"] = os.popen("echo $TURBODIR").read() 
       elif "maxmem" not in params:
           params["maxmem"] = 3000

       # default parameters for job submission and set the other variables
       if params["submit"]:
           if "ntasks" not in params:
               params["ntasks"] = 8
           elif "partition" not in params:
               params["partition"] = "normal" 
           elif "maxnodes" not in params:
               params["maxnodes"] = 4
           # write the SLURM job submission script 'submit.sh' to the QM calculation home directory 
           turbomole.Slurm.write_submission_script(self.dft_path, params["turbodir"], params["ntasks"], params["partition"])
           CPUS, MEM = turbomole.Slurm.get_partition_info(params["partition"])
           MEM_per_CPU = MEM/CPUS
           params["maxmem"] = 0.8*MEM_per_CPU
           njobs_per_node = CPUS/params["ntasks"]
           self.max_njobs = params["maxnodes"]*njobs_per_node
       self.params = params
       return

    def make_dft_subdir(self, specID, db_path):
       # Create the subdirectory for the DFT calculation
       subdir_name = '%05d' % specID
       dft_subdir_path = os.path.abspath(os.path.join(self.dft_path, subdir_name))
       exists = os.path.isdir(dft_subdir_path)
       inDB = False
       if exists:
           rdb = RDB.RDB(db_path)
           db = rdb.db
           dft_spec = db(db.opt_species.path == dft_subdir_path).select().first()
           if dft_spec != None: inDB = True
       else:
           os.mkdir(dft_subdir_path)
          
       return dft_subdir_path, exists, inDB


    def optimize(self, specID, ref_struc_path, TS = False, M = None, rbonds = [], unimolecular = False, path_ref_educts = [], path_ref_products = [],  mfpx_ed_complex = '',  mfpx_prod_complex = ''):


       # initialize the OptimizationTools class from the turbomole module under molsys/util/turbomole.py
       ST = turbomole.OptimizationTools(dft_subdir_path)

       # we only fix the internal coordinates between the atoms involved in bond-order change. So convert the bonds into atoms list.
       active_atoms = []
       for i in set(rbonds):
           active_atoms.append(i+1)

       ###############################   to optimize each species in series     ###########################################
       if not self.params["submit"]:
          os.chdir(dft_subdir_path)

          if TS:
              # Do not perform Fermi smearing. The multiplicity is determined by the educts and products.
              print("TS workflow is not implemented yet.")
              sys.exit(1)
              fermi = False
              #atom, converged, init_energy = ST.common_workflow(fermi, M, active_atoms, self.params["maxmem"], ref_struc_path, self.params["lot"])
              #found, reason = ST.transition_state_workflow(active_atoms, path_ref_educts, path_ref_products)
              #final_energy, zpe = turbomole.Harvest().get_energy()
 
          else:
              # Perform Fermi smearing to find the multiplicity of the equilibrium structures
              fermi = True
              atom, converged, init_energy = ST.common_workflow(fermi, M, active_atoms, self.params["maxmem"], ref_struc_path, self.params["lot"])
              if atom:
                  found = converged
                  final_energy = init_energy
                  zpe = 0
              else:
                  if converged:
                      found, reason = ST.minima_workflow()
                      final_energy, zpe = turbomole.Harvest().get_energy()
                  else:
                      f = open('NOTFOUND','a')
                      f.write('The ridft calculation did not converge.')
                      f.close()
          os.chdir(self.data_dir)
          return found, reason, init_energy, final_energy, zpe

       ################################  to submit to the queue for each species ######################################
       else:
          os.chdir(dft_subdir_path)

          # write the submit.py script which does basically the same thing as the routine written above
          ST.write_submit_py(TS, M, active_atoms, self.params["maxmem"], ref_struc_path, self.params["lot"], unimolecular, path_ref_educts, path_ref_products, mfpx_ed_complex, mfpx_prod_complex)
          # submit the job to the SLURM queuing system and get the assigned job id
          sbatchout = os.popen("sbatch -J spec%d %s" %(specID, os.path.join(self.dft_path,"submit.sh"))).read()
          jobid = sbatchout.split()[3]

          os.chdir(self.data_dir)
          return jobid

    def get_multiplicity(dft_subdir_path):
       GT = turbomole.GeneralTools(dft_subdir_path)
       nalpha, nbeta = GT.get_nalpha_and_nbeta_from_ridft_output()
       M = GT.calculate_spin_multiplicity_from(nalpha, nbeta) 
       return M

    def get_energy(dft_subdir_path, atom):       
       """ Read the energy from the aoforce output or from the ridft output.
       SPE: Single point energy
       ZPE: Zero point vibrational energy
       """
       GT = turbomole.GeneralTools(dft_subdir_path)
       if atom:
           SPE = GT.get_energy_from_ridft_out()
           ZPE = 0.0
       else:
           SPE, ZPE = GT.get_energy_from_aoforce_out() 
       return  SPE, ZPE

    def get_mol(dft_subdir_path):
       os.system("t2x %s/coord > %s/coord.xyz" %(dft_subdir_path, dft_subdir_path))
       mol = molsys.mol.from_file(os.path.join(dft_subdir_path,"coord.xyz"))
       return mol




#
# Helper functions
#
def get_mol_from_opt_spec(ospec):
    # get mol object from DB
    fname, mfpxf = db.opt_species.mfpx.retrieve(ospec.mfpx)
    mfpxs = mfpxf.read().decode('utf-8')
    mfpxf.close()
    mol = molsys.mol.from_string(mfpxs)
    mol.addon("graph")
    mol.graph.make_comp_graph()
    return mol

def get_opt_spec_path(ospec):
    fname, mfpxf = db.opt_species.mfpx.retrieve(ospec.mfpx)
    ospec_mfpxf_path = mfpxf.name
    mfpxf.close()
    return ospec_mfpxf_path

def get_md_spec_mfpx(md_spec):
    fname, mfpxf = db.md_species.mfpx.retrieve(md_spec.mfpx)
    md_spec_mfpxf_path = mfpxf.name
    mfpxf.close()
    return md_spec_mfpxf_path

def get_ncurjobs(jobids):
    squeueout = os.popen('squeue --format="%A"').read()
    squeuelist=squeueout.split()
    curjobids=set(jobids).intersection(squeuelist)
    ncurjobs = len(curjobids)
    return ncurjobs, curjobids



######################################################################################################################
######################################################################################################################
#
# Start of main program 
#
if len(sys.argv) < 2:
    print ("usage:  opt_md_species <db_path> <pdlp_file> <stage>")
    exit()
    

db_path   = sys.argv[1]
pdlp_path = sys.argv[2]
pdlp_path = os.path.abspath(pdlp_path)
stage     = sys.argv[3]
start_lot = sys.argv[4]
cmd_file  = sys.argv[5]

assert os.path.isfile(cmd_file), "command file exists!"

print ("open database %s" % db_path)
rdb = RDB.RDB(db_path)
print ("dealing with MD from file %s and stage %s"  % (pdlp_path, stage))

# get all entries in md_species not TS (access pydal  directly TBI: some clever routines in rdb to handle this)
db = rdb.db
md = db((db.md.path == pdlp_path) & (db.md.stage == stage)).select().first()

reactions = db(db.reactions).select() 

start_lotID = rdb.get_lot(start_lot)

# read param set. Examples are:
# ------------------------------
# DFT could look like
#params = { "calculator"        : "turbomole" 
#         , "species"           : "eq" or "ts"
#         , "data_storage_path' : '/home/oyoender/DATA/'
#         , "lot"               : "tpssh/TZVP"
#         , "maxmem"            : 3000
#         , "submit"            : True
#         , "turbodir"          : /opt/software/user-soft/turbomole/release
#         , "ntasks"            : 8
#         , "maxnodes"          : 4
#         , "partition"         : "normal"
#         }

file = open(cmd_file, "r")
content = file.read()
params = ast.literal_eval(content)

# sanity check(s)
assert "calculator" in params, "Calculator defined"
assert "lot" in params, "Level of Theory given for calculator"

if params["calculator"] == "turbomole":
    calculator = turbomole_calculator(params)

lotID = rdb.get_lot(params["lot"])

path = ""
dft_subdir_paths = {}
specIDs = {}
rbonds = []
curjobids = []
ncurjobs = 0
jobids = []



spec =  db(db.species).select()
n_spec = len(spec)
n_ts = len(reactions)-1
n_eq = n_spec - n_ts


# Loop over the reactions
for r in reactions:
    # get all species for this reaction
    reac2spec   = db((db.reac2spec.reactionsID == r)).select()
    reac2eq_spec  = db((db.reac2spec.reactionsID == r) & (db.reac2spec.label != 0)).select()
    reac2ts_spec = db((db.reac2spec.reactionsID == r) & (db.reac2spec.label ==  0)).select().first()




    #################################### for the TS ######################################
    if params["species"] == "ts":
        if r.id != 1:
            # We need the QM optimized educt and product species 
            # 1) to determine the spin multiplicity of the reaction/TS and 
            # 2) to compare the end points of intrinsic reaction coordinate.
            # Therefore, select the optimized educts and products at the specified QM lot.
            reac2educt_spec = db((db.reac2spec.reactionsID == r) & (db.reac2spec.label == -1)).select()
            n_ed = len(reac2educt_spec)
            path_ref_educts = []
            M_educts = - n_ed + 1

            skip = False
            for ed in reac2educt_spec:
                oed = db((db.opt_species.speciesID == ed.speciesID) & (db.opt_species.lotID == lotID)).select().first()
                if oed != None:
                    path_ref_educts.append(oed["path"])
                    infos = oed["info"].split(';')
                    for info in infos:
                        if 'M' in info:
                            M_ed = int(info.split("=")[1])
                    M_educts += M_ed
                else:
                    skip = True
                    print('%s optimized species for the species %d does not exist in the database.' %(params["lot"], ed.speciesID))

            reac2proc_spec  = db((db.reac2spec.reactionsID == r) & (db.reac2spec.label ==  1)).select()
            n_prod = len(reac2proc_spec)
            path_ref_products = []
            M_products = - n_prod + 1
            for prod in reac2proc_spec:
                oprod = db((db.opt_species.speciesID == prod.speciesID) & (db.opt_species.lotID == lotID)).select().first()
                if oprod != None:
                    path_ref_products.append(oprod["path"])
                    infos = oprod["info"].split(';')
                    for info in infos:
                        if 'M' in info:
                            M_prod = int(info.split("=")[1])
                    M_products += M_prod
                else:
                    skip = True
                    print('%s optimized species for the species %d does not exist in the database.' %(params["lot"], ed.speciesID))

            if not skip:
                # Determine the multiplicity of the reaction
                if M_educts == M_products:
                    M = M_educts
                else:
                    M = min(M_educts, M_products)
                    print('The multiplicity of the educts and the products are not the same. The lower one is assigned.')

                ed_comp_path   = ''
                prod_comp_path = ''
                if n_ed == 1 and n_prod == 1:
                    unimolecular = True
                else:
                    unimolecular = False

                mfpx_ed_complex   = ''
                mfpx_prod_complex = ''
                if not unimolecular:
                    revent    = db( db.revent.reactionsID == r.id ).select().first()
                    ed_comp   = db((db.md_species.reventID == revent.id) & (db.md_species.react_compl == True) & (db.md_species.foffset == -1)).select().first()
                    prod_comp = db((db.md_species.reventID == revent.id) & (db.md_species.react_compl == True) & (db.md_species.foffset ==  1)).select().first()
                    mfpx_ed_complex   = get_md_spec_mfpx(ed_comp)
                    mfpx_prod_complex = get_md_spec_mfpx(prod_comp)

                # Now select the start_lot (e.g. ReaxFF) pre-optimized TS species.
                ots =  db((db.opt_species.speciesID == reac2ts_spec.speciesID) & (db.opt_species.lotID == start_lotID)).select().first()
                ots_mfpx_path = get_opt_spec_path(ots)
                rbonds = ots["rbonds"]
                specID = reac2ts_spec["speciesID"] 
                

                if params["calculator"] == "turbomole":

                    ################################# submission to the queuing system ##################################
                    if params["submit"]:
                        # submit the jobs to the specifies number of total cores.
                        while ncurjobs == calculator.max_njobs:
                            print("Maximum number of jobs running at the same time is reached. Waiting for the jobs %s to finish." %str(list(curjobids)))
                            time.sleep(30)
                            ncurjobs, curjobids = get_ncurjobs(jobids)
                        # submit the job to the queue and get the job id from the queing system
                        dft_subdir_path, exists, inDB = calculator.make_dft_subdir(specID, db_path)
                        if not exists and not inDB:
                            jobid = calculator.optimize(specID, ots_mfpx_path, True, M, rbonds, unimolecular, path_ref_educts, path_ref_products, mfpx_ed_complex, mfpx_prod_complex)
                            # update the variables
                            jobids.append(jobid)
                            dft_subdir_paths[ots] = dft_subdir_path
                        elif exists and not inDB:
                            print('The directory %s already exists. However, there is no entry in the DB. Please, check if the directory contains the results and if so add it to the database; otherwise, remove the directory.' %dft_subdir_path)
                        else:
                            print('The directory %s already exists and is in the DB.' %dft_subdir_path)
                        ncurjobs, curjobids = get_ncurjobs(jobids)




    ############################## for the equilibrium structures ########################
    else:
        for spec in reac2eq_spec:
            specID = spec["speciesID"]
            # Select the start_lot (e.g. ReaxFF) optimized equilibrium species.
            # At the moment it selects only the first species because all the rest is the same.
            ospec = db((db.opt_species.speciesID == specID) & (db.opt_species.lotID == start_lotID)).select().first()
            ospec_mfpx_path = get_opt_spec_path(ospec)
            if params["calculator"] == "turbomole":
 
                ################################# submission to the queuing system ##################################
                if params["submit"]:
                    # submit the jobs to the specifies number of total cores.
                    while ncurjobs == calculator.max_njobs:
                        print("Maximum number of jobs running at the same time is reached. Waiting for the jobs %s to finish." %str(list(curjobids)))              
                        time.sleep(30)
                        ncurjobs, curjobids = get_ncurjobs(jobids)
                    # submit the job to the queue and get the job id from the queing system
                    dft_subdir_path, exists, inDB = calculator.make_dft_subdir(specID, db_path)
                    if not exists and not inDB:
                        jobid = calculator.optimize(specID, ospec_mfpx_path)
                        # update the variables
                        jobids.append(jobid)
                        dft_subdir_paths[ospec] = dft_subdir_path
                    elif exists and not inDB:
                        print('The directory %s already exists. However, there is no entry in the DB.' %dft_subdir_path)
                    else:
                        print('The directory %s already exists and is in the DB.' %dft_subdir_path)
                    ncurjobs, curjobids = get_ncurjobs(jobids)
                    # if all of the jobs are submitted, wait until all of them are finished
                    if len(jobids) == n_eq:
                        print("All of the jobs are submitted.")
                        #while not ncurjobs == 0:
                        #    print("Waiting for the final jobs %s to finish..." %str(list(curjobids)))
                        #    time.sleep(30)
                        #    ncurjobs, curjobids = get_ncurjobs(jobids)
                        #print("All of the jobs are finished.")
 
 
                ##################################### optimize in series  ###########################################
                else:
                    dft_subdir_path, exists, inDB = calculator.make_dft_subdir(specID, db_path)
                    if not exists and not inDB:
                        found, reason, init_energy, final_energy, zpe = calculator.optimize(specID, ospec_mfpx_path)
                        dft_subdir_paths[ospec] = dft_subdir_path
                    elif exists and not inDB:
                        print('The directory %s already exists. However, there is no entry in the DB.' %dft_subdir_path)
                    else:
                        print('The directory %s already exists and is in the DB.' %dft_subdir_path)
 
            else:
               print("Unknown calculator!")
               sys.exit(1)

