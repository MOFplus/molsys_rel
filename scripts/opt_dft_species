#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""test script to optimize all systems in the DB

all systems with zero energy and not TS are picked and optimized
"""

import pylmps
import molsys
import sys
import getopt
import os
import time
from molsys.util import RDB
from molsys.util import turbomole

def get_ncurjobs(jobids):
    squeueout = os.popen('squeue --format="%A"').read()
    squeuelist=squeueout.split()
    curjobids=set(jobids).intersection(squeuelist)
    ncurjobs = len(curjobids)
    return ncurjobs

def usage():
    print(" -------------------------------------------------------------------------\n",
            "usage: opt_dft_species <db_path>                                         \n",
            "-------------------------------------------------------------------------\n",
            " Options:                                                                \n",
            "-m/--method=<lot_DFT>    DFT functional and basis set, e.g. tpss/SVP.    \n",
            "-M/--maxmem=<maxmem>     Maximum memory in MB/core.                      \n",
            "-s/--submit              to enable submission of the jobs via SLURM.     \n",
            "                         Note: only SMP parallel.                        \n",
            "-t/--turbodir=<TURBODIR> the path to the Turbomole directory.            \n",
            "-n/--ntasks=<ntasks>     requests allocation with a max ntasks. (SLURM) \n",
            "-p/--partition=<partition> the partition to be used. (SLURM)            \n",
            "-N/--maxnodes=<maxnodes> the max number of nodes to submit.             \n",
            "------------------------------------------------------------------------\n")
    return


if len(sys.argv) < 2:
    usage()
    exit
if sys.argv[1] in ('-h','--help'):
    usage()
    exit()

# Get the system arguments
db_path = os.path.abspath(sys.argv[1])
argv = sys.argv[2:]

# Default values for the options
lot_DFT = "tpss/SVP"
max_mem = 500 
submit = False
TURBODIR = os.popen("echo $TURBODIR").read()
ntasks = 8
maxnodes = 3
partition = "normal"

# Read the options
try:
    opts, argv =  getopt.getopt(argv, 'm:M:st:n:p:N:', ['method=','maxmem=','submit','turbodir=','ntasks=','partition=','maxnodes='])
except getopt.GetoptError as err:
    print(err)
    usage()
    sys.exit()

for opt, arg in opts:
    if opt in ("-m", "--method"):
        lot_DFT = arg
    if opt in ("-M", "--maxmem"):
        max_mem = int(arg)
    elif opt in ("-s", "--submit"):
        submit = True
    elif opt in ("-t", "--turbodir"):
        TURBODIR = arg
    elif opt in ("-n", "--ntasks"):
        ntasks = int(arg)
    elif opt in ("-p", "--partition"):
        partition = arg
    elif opt in ("-N", "--maxnodes"):
        maxnodes = int(arg)

# Create a DFT folder with the name of the method
dft_functional = lot_DFT.split("/")[0]
basis_set = lot_DFT.split("/")[1]
dft_dir_name = "-".join([dft_functional,basis_set])
maindir = os.getcwd()
dft_path = os.path.join(maindir,dft_dir_name)
if not os.path.isdir(dft_path):
    os.mkdir(dft_path)

# For jobs submission write the job submission script and set the variables
if submit:
    turbomole.Slurm.write_submission_script(dft_path, TURBODIR, ntasks, partition)
    CPUS, MEM = turbomole.Slurm.get_partition_info(partition)
    MEM_per_CPU = MEM/CPUS
    max_mem = 0.8*MEM_per_CPU
    njobs_per_node = CPUS/ntasks
    max_njobs = maxnodes*njobs_per_node


# The zero point energy (ZPE) correction factor dictionary
f_ZPE_dict = {'tpss/SVP':1.0019,'b3-lyp/SVP':0.9912, 'pbe0/SVP':0.9817, 'pbe/SVP':1.0179, 
                                'b3-lyp/TZVP':0.9896,'pbe0/TZVP':0.9830,
              # Reference: https://dx.doi.org/10.1021/jp508422u 
              'tpssh/TZVP':0.9874}
              # Reference:  https://dx.doi.org/10.1021/jp0519464

# Open the database
print ("open database %s" % db_path)
rdb = RDB.RDB(db_path)

# Get all entries in md_species not TS (access pydal  directly TBI: some clever routines in rdb to handle this)
db = rdb.db

# Select all the UNIQUE REACTION events from the database
revents = db(db.unique_revent).select()

# Perform the QM calculation only on the species which are unique.
jobids = []
ncurjobs = 0


for r in revents:
#for r in rows:

    # Just get the first revent of this unique revent class
    cur_event = db(db.revent.unique_reventID == r).select().first()
    md_specs = db((db.md_species.reventID == cur_event)).select()


    for md_spec in md_specs:
       # Set up the active atoms which whose internal coordinates will be 
       # kept fixed during the geometry optimization (for the transition states.)
       foffset = md_spec.foffset
       # if not TS --> No constraint 
       if md_spec.foffset != 0: 
           active_atoms = []
       # if TS --> Get the list of atoms defining the reactive bonds
       else:
           active_atoms = list(set(cur_event.rbonds))

 
       # Get the directory of the coordinates file of the MD species
       fname, mfpxf = db.md_species.mfpx.retrieve(md_spec.mfpx)
       md_mfpx_path = mfpxf.name

#================================ modified up to here.
   
   
    
       # Create the subdirectory for the DFT calculation
       subdir_name = '%05d' % md_spec.id
       dft_subdir_path = os.path.join(dft_path, subdir_name)
       if not os.path.isdir(dft_subdir_path):
           os.mkdir(dft_subdir_path)
       else:
           sys.exit('The directory %s already exists' % dft_subdir_path)
   
       
       #--------------- MAIN ------------------#
       # Submission Tools
       ST = turbomole.SubmissionTools(dft_subdir_path)
       
       if submit:
           ST.write_submit_py(foffset, active_atoms, max_mem, md_mfpx_path, lot_DFT)
           while ncurjobs == max_njobs:
               time.sleep(30)
               ncurjobs = get_ncurjobs(jobids)
               print("Inside the while loop:","jobids=", jobids, "ncurjobs=", ncurjobs, "njobs_per_node=", max_njobs)                                     
           os.chdir(dft_subdir_path)
           sbatchout = os.popen("sbatch -J spec%d %s" %(md_spec.id, os.path.join(dft_path,"submit.sh"))).read()
           os.chdir(dft_path)
           jobids.append(sbatchout.split()[3])
           ncurjobs = get_ncurjobs(jobids)
           print("Outside the while loop:","jobids=", jobids, "ncurjobs=", ncurjobs, "njobs_per_node=", max_njobs)              
       else:
           atom = ST.common_workflow(active_atoms, max_mem, md_mfpx_path, lot_DFT)
           if not atom:
              if foffset == 0:
                  found = ST.transition_state_workflow(active_atoms)
              else:
                  found = ST.minima_workflow()
           if found:
               os.system("touch found")
           else:
               os.system("touch notfound")

#for r in rows:
#    if r.id not in similar_dict:
#        fname = "%s/storage/xyz/%s" %(db_path,r.xyz)
#        subdir_name = '%05d' % r.id
#        dft_subdir_path = os.path.join(dft_path, subdir_name)
#        found = os.path.join(dft_subdir_path,"found")
#        notfound = os.path.join(dft_subdir_path,"notfound")
#        while not (os.path.isfile(found) or os.path.isfile(notfound)):
#            time.sleep(10)
#
#if found:
#    final_energy = turbomole.Harvest(dft_subdir_path).get_energy(f_ZPE_dict[lot_DFT])
#    opt_mol = GT.coord_to_mol()
#    rdb.add_opt_species(opt_mol, lot_DFT, final_energy, md_spec.id)


#rows = db((db.md_species.energy == 0.0) & (db.md_species.foffset != 0)).select()
#
#lot = rdb.get_lot("ReaxFF")
#
#for r in rows:
#    print ("retreive species %d (type %d) from reaction event %d" % (r.spec, r.foffset, r.reventID))
#    print (r.smiles)
#    # get mol object from DB
#    fname, mfpxf = db.md_species.mfpx.retrieve(r.mfpx)
#    mfpxs = mfpxf.read().decode('utf-8')
#    mfpxf.close()
#    mol = molsys.mol.from_string(mfpxs)
#    # setup lammps and minimize with reax
#    pl = pylmps.pylmps("reax")
#    pl.setup(mol = mol, local=True, ff="ReaxFF")
#    init_energy = pl.calc_energy()
#    final_energy = pl.MIN(0.01)
#    print ("\n\n#####################################")
#    print ("initial %12.6f  final %12.6f " % (init_energy, final_energy))
#    print ("########################################\n\n")
#    # store these results to the DB
#    # first update coords and get mol object back from lammps
#    pl.update_mol()
#    opt_mol = pl.mol
#    # update the energy value
#    r.update_record(energy=init_energy)
#    rdb.add_opt_species(opt_mol, lot, final_energy, r.id)
#    pl.end()
#
#
#
#
#
#
