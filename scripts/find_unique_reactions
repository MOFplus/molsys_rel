#!/usr/bin/env python3
# -*- coding: utf-8 -*-

""" script to find all unique reactions in the DB

"""

import pylmps
import molsys
import sys
import os
import numpy as np
from molsys.util import RDB
from molsys.util import print_progress


def check_all(bool_list):
    if len(bool_list) > 0:
        return all(bool_list)
    else:
        return False


def add_compare_data(comparer, mdpec):

    for m in mdspec.sort(lambda row: row.sumform):
    
        # get mol object from DB
        fname, mfpxf = db.md_species.mfpx.retrieve(m.mfpx)
        mfpxs = mfpxf.read().decode('utf-8')
        mfpxf.close()
        mol = molsys.mol.from_string(mfpxs)
    
        sumform = mol.get_sumformula()
    
        mol.addon("graph")
        mol.graph.make_graph()
        molg = mol.graph.molg

        if (m.foffset ==  0 ):
            comparer["molgraph:ts"].append(molg)
            comparer["sumform:ts"].append(sumform)
        if (m.foffset == -1 ):
            comparer["molgraph:educt"].append(molg)
            comparer["sumform:educt"].append(sumform)
        if (m.foffset ==  1 ):
            comparer["molgraph:product"].append(molg)
            comparer["sumform:product"].append(sumform) 

    return

####################################################################################
#
# TODO 
#
#  1) Make option to filter only reactions involving changes in the C-graph
#      -> Do this by new make_graph (e.g. make_comp_graph) in molsys 
#
#  2) Remove Bottlenecks
#
####################################################################################

if len(sys.argv) < 2:
    print ("usage:  find_unique_reactions <db_path> <pdlp_file> <stage>")
    exit()
    
#
# Read command line arguments
#
db_path   = sys.argv[1]
pdlp_path = sys.argv[2]
pdlp_path = os.path.abspath(pdlp_path)
stage     = sys.argv[3]

print ("open database %s" % db_path)
rdb = RDB.RDB(db_path)
print ("dealing with MD from file %s and stage %s"  % (pdlp_path, stage))

db = rdb.db
md = db((db.md.path == pdlp_path) & (db.md.stage == stage)).select().first()
revents = db((db.revent.mdID == md)).select()
num_all = (len(revents))

# init counter
num_unique = 0

#
# Read in all unique reactions
#
unique_reactions = []
unique_comparer = {}
for r in revents:
    if r["unique_reventID"] is not None:
        unique_reactions.append(r)
        unique_comparer[r["unique_reventID"]] = { "molgraph:ts" : []
                                                , "sumform:ts"  : []
                                                , "molgraph:educt" : []
                                                , "sumform:educt"  : []
                                                , "molgraph:product" : []
                                                , "sumform:product"  : []
                                                }

        mdspec = db((db.md_species.reventID == r)).select()

        add_compare_data(unique_comparer[r["unique_reventID"]], mdspec)


num_unique = len(unique_comparer)

#
# Main loop to sort out non-unique reactions
#
count = 0

for r in revents:

    count += 1

    print_progress.print_progress(count, num_all)

    # Check if revent has alredy record field unique_revent and skip in this case 
    if r["unique_reventID"] is not None:
        continue
    

    is_unique  = True
    same_ts    = False 
    same_pr    = False 
    same_ed    = False 
    same_pr_ed = False 
    same_ed_pr = False 

    is_reversed = False

    # get all md_species for this event
    mdspec = db((db.md_species.reventID == r)).select()
    if len(mdspec) > 0:

        # Note: We have to sort the mdspecies to always match the same species in order
        #       to match them in the comparison
        for m in mdspec.sort(lambda row: row.sumform):

            # get mol object from DB
            fname, mfpxf = db.md_species.mfpx.retrieve(m.mfpx)
            mfpxs = mfpxf.read().decode('utf-8')
            mfpxf.close()
            mol = molsys.mol.from_string(mfpxs)

            have_ts = (m.foffset == 0 )
            have_ed = (m.foffset == -1)
            have_pr = (m.foffset == 1 )
            
            mol.addon("graph")
            mol.graph.make_graph()

            #
            # compare with elements in unique_reaction list
            #

            for ur in unique_reactions:
                ur_mdspec = db((db.md_species.reventID == ur)).select()

                for ur_m in ur_mdspec.sort(lambda row: row.sumform):

                    fname, mfpxf = db.md_species.mfpx.retrieve(ur_m.mfpx)
                    mfpxs = mfpxf.read().decode('utf-8')
                    mfpxf.close()
                    ur_mol = molsys.mol.from_string(mfpxs)

                    ur_mol.addon("graph")
                    ur_mol.graph.make_graph()

                    # Quick check(s)
                    is_same = ( ur_mol.get_sumformula() == mol.get_sumformula() ) 

                    if not is_same:
                        continue      # We need to continue since maybe edukt = product for example

                    # ellaborate check
                    is_same = molsys.addon.graph.is_equal(mol.graph.molg, ur_mol.graph.molg)

                    if not is_same:
                        continue

                    same_ts = same_ts or (have_ts and ur_m.foffset ==  0)
                    same_ed = same_ed or (have_ed and ur_m.foffset == -1)
                    same_pr = same_pr or (have_pr and ur_m.foffset ==  1)

                    same_pr_ed = same_pr_ed or (have_ed and ur_m.foffset ==  1)
                    same_ed_pr = same_ed_pr or (have_pr and ur_m.foffset == -1)

                    #if have_ed:
                    #    same_ed.append(ur_m.foffset == -1)
                    #    same_pr_ed.append(ur_m.foffset ==  1)
                    #elif have_pr:
                    #    same_pr.append(ur_m.foffset == 1)
                    #    same_ed_pr.append(ur_m.foffset == -1)
                    #elif have_ts:
                    #    same_ts.append(ur_m.foffset ==  0)


    # many boolean operations, which are probably not fast in python
    same_reaction = (same_ts and same_pr and same_ed) 
    back_reaction = (same_ts and same_pr_ed and same_ed_pr)

    is_reversed = back_reaction

    is_unique = not (same_reaction or back_reaction)


    if is_unique:
        unique_reactions.append(r)
        num_unique += 1

        #
        # Add unique reaction entry to database. 
        #

        revID = rdb.register_unique_revent(
            r["frame"],
            r["ed"],
            r["ts"],
            r["pr"],
            r["tr_ed"],
            r["tr_pr"],
            r["rbonds"]
        )

        # Update reaction event
        r.update_record(unique_reventID=revID)
        r.update_record(reversed=is_reversed)
    else:
        # update reaction event
        r.update_record(unique_reventID=ur["unique_reventID"])
        r.update_record(reversed=is_reversed)


        #db.commit()

num_non_unique = num_all - num_unique
db.commit()


print("Num unique : " + str(num_unique)) 
print("Num non unique : " + str(num_non_unique)) 
