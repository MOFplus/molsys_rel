#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""test script to optimize all systems in the DB

all systems with zero energy and not TS are picked and optimized
"""

import pylmps
import molsys
import sys
import os
import numpy as np
from molsys.util import RDB


class base_calculator:

    def __init__(self, mol, params : dict):
        self.name = "base"
        self.mol = mol
        self.natoms = mol.get_natoms()
        self.energy = 0.0
        self.force  = np.zeros([self.natoms, 3], dtype="float64")  
        return

    def calc_energy(self):
        return self.energy

    def calc_energy_force(self):
        return self.energy, self.force

    def optimize(TS=False):
        final_energy = 0.0
        print("You called the base class")
        return final_energy

class reaxff_calculator(base_calculator):

    def __init__(self, mol, params : dict):
        super(base_calculator, self).__init__()
        self.pl = pylmps.pylmps("opt")
        self.pl.setup(mol = mol, local=True, ff="ReaxFF")
        return

    def calc_energy(self):
        return self.calc_energy()

def get_mol_from_opt_spec(ospec):
    # get mol object from DB
    fname, mfpxf = db.opt_species.mfpx.retrieve(ospec.mfpx)
    mfpxs = mfpxf.read().decode('utf-8')
    mfpxf.close()
    mol = molsys.mol.from_string(mfpxs)
    mol.addon("graph")
    mol.graph.make_comp_graph()

    return mol

if len(sys.argv) < 2:
    print ("usage:  opt_md_species <db_path> <pdlp_file> <stage>")
    exit()
    
### default ####
forceconst = 1000.0


db_path   = sys.argv[1]
pdlp_path = sys.argv[2]
pdlp_path = os.path.abspath(pdlp_path)
stage     = sys.argv[3]

lot = "ReaxFF"
if len(sys.argv) > 4:
   lot = sys.argv[4]

only_unique_reactions=False
if len(sys.argv) > 5:
   only_unique_reactions=bool(sys.argv[5])


print ("open database %s" % db_path)
rdb = RDB.RDB(db_path)
print ("dealing with MD from file %s and stage %s"  % (pdlp_path, stage))

# get all entries in md_species not TS (access pydal  directly TBI: some clever routines in rdb to handle this)
db = rdb.db
md = db((db.md.path == pdlp_path) & (db.md.stage == stage)).select().first()

reactions = db(db.reactions).select() 

start_lot = rdb.get_lot("fromMD")

for r in reactions:
    # get all species for this reaction
    reac2spec = db((db.reac2spec.reactionsID == r)).select()

    for r2s in reac2spec:
        specID = r2s["speciesID"]

        ospec = db((db.opt_species.speciesID == specID) & (db.opt_species.lotID == start_lot)).select().first()

        mol = get_mol_from_opt_spec(ospec)

        molg_init = mol.graph.molg

        if r2s["label"] == 1 or r2s["label"] == -1: 
           TS = False
        elif r2s["label"] == 0:
           TS = True

    
        if TS:
           if start_lot == rdb.get_lot("fromMD"):

              # get md_species for this species
              mdspec = db(db.md_species.speciesID == specID).select().first()

              # get revent for this mdspecies
              cur_event = db(db.revent.id == mdspec["reventID"]).select().first()

              rbonds = cur_event["rbonds"]

              rbonds = np.array(rbonds)
              nrbonds = len(rbonds)//2
              rbonds.shape = (nrbonds, 2)
              # all molecules are non-perioidc  .. just compute current bond distance
              bondlength = []
              for i in range(nrbonds):
                  r = mol.xyz[rbonds[i,0]]-mol.xyz[rbonds[i,1]]
                  bondlength.append(np.sqrt((r*r).sum()))
  
    
        #
        # setup lammps and minimize with level of theory in lot (default ReaxFF)
        #
        pl = pylmps.pylmps("opt")
        if lot == "ReaxFF":
            pl.setup(mol = mol, local=True, ff="ReaxFF")
        elif lot in ["GFN0","GFN1","GFN2"]:

            gfn_param_set = { "GFN0" : 0
                            , "GFN1" : 1
                            , "GFN2" : 2
                            }

            # instantiate the external potential expot_xtb

            # We use mainly default settings, but set the maximal iterations higher 
            # since the structures are very deformed in the MD simulation
            ep = pylmps.expot_xtb(mol,gfn_param_set[lot],verbose=0,maxiter=1000)

            # we need to register the objects callback as a global function
            callback = ep.callback

            # now add the expot object together with the name of the global callback
            pl.add_external_potential(ep, "callback")

            # setup xTB
            pl.setup(local=True, mol = mol, ff="xTB")

        init_energy = pl.calc_energy()
        if TS:
            for i in range(rbonds.shape[0]):
                par = (forceconst, bondlength[i])
                pl.add_restraint("bnd", tuple(rbonds[i]), par)
        final_energy = pl.MIN(0.01)
        if TS:
            pl.clear_restraints()
        # final_energy = pl.calc_energy()
        print ("\n\n########################################")
        print ("initial %12.6f  final %12.6f " % (init_energy, final_energy))
        print ("########################################\n\n")
        # store these results to the DB
        # first update coords and get mol object back from lammps
        pl.update_mol()
        opt_mol = pl.mol
        opt_mol.addon("graph")
        opt_mol.graph.make_comp_graph()
        molg_opt = opt_mol.graph.molg

        is_equal, error_code = molsys.addon.graph.is_equal(molg_init, molg_opt)

        if error_code != 0:
           print("Error during molgraph comparison!")
           sys.exit(1)

        # add to db newly optimized structure
        changed = not is_equal
        rdb.add_opt_species(opt_mol, lot, final_energy, specID, path="",change_molg=changed)
        pl.end()






